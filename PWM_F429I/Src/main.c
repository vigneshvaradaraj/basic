/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32_f429xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define PLL_M  4
#define PLL_N  180
#define PLL_P  0
/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
void config_clock()
{
	//1)trurn on the HSE
	RCC->CR |= RCC_CR_HSEON;
	//wait for HSE ready
	while(!(RCC->CR & RCC_CR_HSERDY));
	//2)set the power enable clock and voltage regulator
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_VOS;

	//3)config the flash prefetch and latancy related settings
	FLASH->ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN |FLASH_ACR_LATENCY_5WS;
	//4)config the prescalars hclk, pclk1, pclk2
	//AHB PR
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	//APB1 PR
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;
	//APB2 PR
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
	//5) config the main pll
//	RCC->PLLCFGR = (PLL_M << 0) | (PLL_N << 6) | (PLL_P << 16) | (RCC_PLLCFGR_PLLSRC_HSE);
//    //6)enable PLL and wait for it to become ready
//	RCC->CR |= RCC_CR_PLLON;
//	while(!(RCC->CR & RCC_CR_PLLRDY));
	//7) select the clock source and wait for it to be set
	RCC->CFGR |= RCC_CFGR_SW_HSE;//selecting HSE as system clock source
	//while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

void TIM3_PWM_Init(void)
{
    /* Step 1: Enable GPIO clock for TIM3 pins */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN; // Enable GPIOB clock

    /* Step 2: Configure PB4 (TIM3_CH1) as Alternate Function */
    GPIOB->MODER &= ~(3UL << (4 * 2));  // Clear mode bits for PB4
    GPIOB->MODER |= (2UL << (4 * 2));   // Set mode to Alternate Function

    GPIOB->AFR[0] &= ~(0xF << (4 * 4)); // Clear AFRL bits for PB4
    GPIOB->AFR[0] |= (2UL << (4 * 4));  // Set AF2 for TIM3_CH1

    /* Step 3: Enable TIM3 clock */
    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

    /* Step 4: Configure TIM3 for PWM mode */
    //becuase the source clock is HSE 8mhz
    TIM3->PSC = 799; // Set prescaler to divide clock (8 MHz / (799 + 1) = 10 kHz)
    TIM3->ARR = 99;  // Auto-reload value to set PWM frequency (10 kHz / (99 + 1) = 100 Hz)

    TIM3->CCMR1 &= ~TIM_CCMR1_OC1M;        // Clear output compare mode bits for channel 1
    TIM3->CCMR1 |= (6UL << TIM_CCMR1_OC1M_Pos); // Set PWM mode 1 (OC1M = 110)
    TIM3->CCMR1 |= TIM_CCMR1_OC1PE;       // Enable preload for CCR1

    TIM3->CCR1 = 10; // Set duty cycle to 50% (CCR1 / ARR = 50 / 100) * 100

    TIM3->CCER |= TIM_CCER_CC1E; // Enable output on TIM3_CH1

    /* Step 5: Enable TIM3 */
    TIM3->CR1 |= TIM_CR1_CEN; // Enable TIM3 counter
}
void set_duty_cycle(int duty_cycle)
{
	TIM3->CR1 &= ~(TIM_CR1_CEN); // Enable TIM3 counter
	TIM3->CCR1 = duty_cycle;
	TIM3->CR1 |= TIM_CR1_CEN; // Enable TIM3 counter
}
void delay(void)
{
	for(int i = 0;i < 0x00002fff;i++);
	//for(int j = 0;j < 0x0fffffff;j++);
}

int main(void)
{
    /* Loop forever */

	int i = 0;
	config_clock();
	TIM3_PWM_Init();
	for(;;)
	{
		set_duty_cycle(i++);
		if(i >= 100)
		{
			i = 0;
		}
		delay();
	}
}
