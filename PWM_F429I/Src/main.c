/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32_f429xx.h"
#include "cm4.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define PLL_M  4
#define PLL_N  180
#define PLL_P  0
/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
void config_clock()
{
	//1)trurn on the HSE
	RCC->CR |= RCC_CR_HSEON;
	//wait for HSE ready
	while(!(RCC->CR & RCC_CR_HSERDY));
	//2)set the power enable clock and voltage regulator
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_VOS;

	//3)config the flash prefetch and latancy related settings
	FLASH->ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN |FLASH_ACR_LATENCY_5WS;
	//4)config the prescalars hclk, pclk1, pclk2
	//AHB PR
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	//APB1 PR
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;
	//APB2 PR
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
	//5) config the main pll
//	RCC->PLLCFGR = (PLL_M << 0) | (PLL_N << 6) | (PLL_P << 16) | (RCC_PLLCFGR_PLLSRC_HSE);
//    //6)enable PLL and wait for it to become ready
//	RCC->CR |= RCC_CR_PLLON;
//	while(!(RCC->CR & RCC_CR_PLLRDY));
	//7) select the clock source and wait for it to be set
	RCC->CFGR |= RCC_CFGR_SW_HSE;//selecting HSE as system clock source
	//while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

void TIM3_PWM_Init(void)
{
    /* Step 1: Enable GPIO clock for TIM3 pins */
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN; // Enable GPIOB clock

    /* Step 2: Configure PB4 (TIM3_CH1) as Alternate Function */
    GPIOB->MODER &= ~(3UL << (4 * 2));  // Clear mode bits for PB4
    GPIOB->MODER |= (2UL << (4 * 2));   // Set mode to Alternate Function

    GPIOB->AFR[0] &= ~(0xF << (4 * 4)); // Clear AFRL bits for PB4
    GPIOB->AFR[0] |= (2UL << (4 * 4));  // Set AF2 for TIM3_CH1

    /* Step 3: Enable TIM3 clock */
    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

    /* Step 4: Configure TIM3 for PWM mode */
    //becuase the source clock is HSE 8mhz
    TIM3->PSC = 799; // Set prescaler to divide clock (8 MHz / (799 + 1) = 10 kHz)
    TIM3->ARR = 99;  // Auto-reload value to set PWM frequency (10 kHz / (99 + 1) = 100 Hz)

    TIM3->CCMR1 &= ~TIM_CCMR1_OC1M;        // Clear output compare mode bits for channel 1
    TIM3->CCMR1 |= (6UL << TIM_CCMR1_OC1M_Pos); // Set PWM mode 1 (OC1M = 110)
    TIM3->CCMR1 |= TIM_CCMR1_OC1PE;       // Enable preload for CCR1

    TIM3->CCR1 = 10; // Set duty cycle to 50% (CCR1 / ARR = 50 / 100) * 100

    TIM3->CCER |= TIM_CCER_CC1E; // Enable output on TIM3_CH1

    /* Step 5: Enable TIM3 */
    TIM3->CR1 |= TIM_CR1_CEN; // Enable TIM3 counter
}
void set_duty_cycle(int duty_cycle)
{
	TIM3->CR1 &= ~(TIM_CR1_CEN); // Disable TIM3 counter
	TIM3->CCR1 = duty_cycle;
	TIM3->CR1 |= TIM_CR1_CEN; // Enable TIM3 counter
}

void config_rtc(void)
{
	RCC->APB1ENR |= (1 << 28);//enable clock to power module
	PWR->CR |= (1 << 8);//enable access to rtc backup domain

	RCC->CSR |= (1 << 0);//enable low speed internal oscillator
	while(!(RCC->CSR & (1 << 1)));//wait until lsi ready

	RCC->BDCR |= (2 << 8);//select low speed internal clock for rtc
	RCC->BDCR |= (1 << 15);//enable rtc clock

	RTC->ISR |= (1 << 7);//set 7th bit to go to initialization mode
	while(!(RTC->ISR & (1 << 6)));//wait until the rtc enters into initialization mode

	//set prescaler value for 1Hz now LSI  = 32KHz
	RTC->PRER |= (127 << 16);
	RTC->PRER |= (255 << 0);

	//set time
	RTC->TR |= ((2 << 16) | (12 << 8) | (30 << 0));//set 2hr 12mnt 30sec

	RTC->ISR &= ~(1 << 7);//clear 7th bit to exit initialization mode
	while(RTC->ISR & (1 << 6));//wait until the rtc exits initialization mode

	PWR->CR &= ~(1 << 8);//disable access to rtc backup domain
}

void config_rtc_wakeup_interrupt(void)
{
	PWR->CR |= (1 << 8);//enable access to rtc backup domain
	RTC->CR &= ~(1 << 10);//disable the wake up timer for initialize auto-reload register
	while(!(RTC->ISR & (1 << 10)));//wait until this bit to set

	//select clock for RTC wake up
	RTC->CR &= ~(7 << 0);//RTC clock / 16 is selected
	//config auto-reload register
	//value 2000 for 1 sec
	RTC->WUTR = (2000 * 5);
	PWR->CR &= ~(1 << 8);//disable access to rtc backup domain
	//need to enable EXTI WAKEUP interrupt line
	EXTI->IMR |= (1 << 22);//enable wake up line 22
	EXTI->FTSR |= (1 << 22);//rising trigger selection
	//need to enable NVIC->SIER register to enable the interrupt
	NVIC_SetPriority(RTC_WKUP_IRQn,2);
	NVIC_EnableIRQ(RTC_WKUP_IRQn);
}

void gpio_init()
{
	//1) ENABLE GPIOG CLK
	RCC->AHB1ENR |= (1 << 6);
	//2) SET PIN AS OUTPUT
	GPIOG->MODER |= (1 << 28);
	GPIOG->MODER |= (1 << 26);
	//3) CONFIG THE OP MODE
	GPIOG->OTYPER = 0;
	GPIOG->OSPEEDR = 0;
}

void set(void)
{
	//GPIOG->BSRR |= (1<<14);//SET THE PIN
	GPIOG->BSRR |= (1<<13);//SET THE PIN
}

void clear(void)
{
	//GPIOG->BSRR |= ((1<<14)<<16);//REST PIN
	GPIOG->BSRR |= ((1<<13)<<16);//REST PIN
}

void delay(void)
{
	int i,j;
	for(i=10;--i;)
	for(j=100000;j--;);
}

int main(void)
{

	config_clock();
	TIM3_PWM_Init();
	gpio_init();
	for (;;)
	{
		set();
		delay();
		clear();
		delay();

		__asm volatile ("wfe");

		while(0);
		//set_duty_cycle(i++);
//		if(i >= 100)
//		{
//			i = 0;
//		}
//		delay();
	}
}
void RTC_WKUP_IRQHandler(void)
{
	while(0);
}
